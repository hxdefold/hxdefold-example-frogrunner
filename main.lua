-- Generated by Haxe 3.4.0 (git build development @ a040551)
local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local _hx_exports = _hx_exports or {}
local Array = _hx_e()
local defold = {}
defold.support = {}
defold.support.Script = _hx_e()
local Coin = _hx_e()
local Controller = _hx_e()
local Ground = _hx_e()
local Hero = _hx_e()
local Messages = _hx_e()
local Platform = _hx_e()
local String = _hx_e()
local Std = _hx_e()
defold.GoMessages = _hx_e()
defold.PhysicsMessages = _hx_e()
defold.SpineMessages = _hx_e()
defold.types = {}
defold.types._Message = {}
defold.types._Message.Message_Impl_ = _hx_e()
local haxe = {}
haxe.io = {}
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()
lua.PairTools = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      _G.table.insert(tbl,Std.string(i:next()));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

defold.support.Script.new = function() 
  local self = _hx_new(defold.support.Script.prototype)
  defold.support.Script.super(self)
  return self
end
defold.support.Script.super = function(self) 
end
defold.support.Script.prototype = _hx_a(
  'init', function(self,_self) 
  end,
  'final', function(self,_self) 
  end,
  'update', function(self,_self,dt) 
  end,
  'on_message', function(self,_self,message_id,message,sender) 
  end,
  'on_input', function(self,_self,action_id,action) 
    do return false end
  end,
  'on_reload', function(self,_self) 
  end
)

Coin.new = function() 
  local self = _hx_new(Coin.prototype)
  Coin.super(self)
  return self
end
Coin.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Coin"] = Coin
Coin.prototype = _hx_a(
  'init', function(self,data) 
    data.collected = false;
  end,
  'on_message', function(self,data,message_id,message,sender) 
    if (message_id) == Messages.StartAnimation then 
      local pos = _G.go.get_position();
      _G.go.animate(_G.go.get_id(),"position.y",_G.go.PLAYBACK_LOOP_PINGPONG,pos.y + 24,_G.go.EASING_INOUTSINE,0.75,message.delay);
    elseif (message_id) == defold.PhysicsMessages.collision_response then 
      if (not data.collected) then 
        data.collected = true;
        _G.msg.post("#sprite",defold.GoMessages.disable);
      end; end;
  end
)
Coin.__super__ = defold.support.Script
setmetatable(Coin.prototype,{__index=defold.support.Script.prototype})

Controller.new = function() 
  local self = _hx_new(Controller.prototype)
  Controller.super(self)
  return self
end
Controller.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Controller"] = Controller
Controller.prototype = _hx_a(
  'init', function(self,data) 
    _G.msg.post("ground/controller#script",Messages.SetSpeed,_hx_o({__fields__={speed=true},speed=data.speed}));
    data.gridw = 0;
    data.spawns = ({});
  end,
  'update', function(self,data,dt) 
    local data1 = data;
    data1.gridw = data1.gridw + data.speed;
    if (data.gridw >= Controller.grid) then 
      data.gridw = 0;
      if (_G.math.random() > 0.2) then 
        local h = Controller.platform_heights[Std.random(Controller.platform_heights.length)];
        local f = "#platform_factory";
        local coins = Controller.coins;
        if (_G.math.random() > 0.5) then 
          f = "#platform_long_factory";
          coins = coins * 2;
        end;
        local p = _G.factory.create(f,_G.vmath.vector3(1600,h,0),nil,({}),0.6);
        _G.msg.post(p,Messages.SetSpeed,_hx_o({__fields__={speed=true},speed=data.speed}));
        _G.msg.post(p,Platform.CreateCoinsMessage,_hx_o({__fields__={coins=true},coins=coins}));
        _G.table.insert(data.spawns,p);
      end;
    end;
  end,
  'on_message', function(self,data,message_id,message,sender) 
    local message_id1 = message_id;
    if (message_id1) == Messages.DeleteSpawn then 
      lua.PairTools.ipairsEach(data.spawns,function(i,p) 
        if (p == message.id) then 
          _G.table.remove(data.spawns,i);
          _G.go.delete(p);
        end;
      end);
    elseif (message_id1) == Messages.Reset then 
      _G.msg.post("hero#script",Messages.Reset);
      lua.PairTools.ipairsEach(data.spawns,function(i1,p1) 
        _G.go.delete(p1);
      end);
      data.spawns = ({}); end;
  end
)
Controller.__super__ = defold.support.Script
setmetatable(Controller.prototype,{__index=defold.support.Script.prototype})

Ground.new = function() 
  local self = _hx_new(Ground.prototype)
  Ground.super(self)
  return self
end
Ground.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Ground"] = Ground
Ground.prototype = _hx_a(
  'init', function(self,data) 
    data.speed = 6;
  end,
  'update', function(self,data,dt) 
    local _g = 0;
    local _g1 = Ground.pieces;
    while (_g < _g1.length) do 
      local p = _g1[_g];
      _g = _g + 1;
      local pos = _G.go.get_position(p);
      if (pos.x <= -228) then 
        pos.x = 1368 + (pos.x + 228);
      end;
      pos.x = pos.x - data.speed;
      _G.go.set_position(pos,p);
      end;
  end,
  'on_message', function(self,data,message_id,message,sender) 
    if (message_id == Messages.SetSpeed) then 
      data.speed = message.speed;
    end;
  end
)
Ground.__super__ = defold.support.Script
setmetatable(Ground.prototype,{__index=defold.support.Script.prototype})

Hero.new = function() 
  local self = _hx_new(Hero.prototype)
  Hero.super(self)
  return self
end
Hero.super = function(self) 
  self.jump_takeoff_speed = 900;
  self.gravity = -20;
  defold.support.Script.super(self);
end
_hx_exports["Hero"] = Hero
Hero.prototype = _hx_a(
  'init', function(self,data) 
    _G.msg.post(".",defold.GoMessages.acquire_input_focus);
    data.position = _G.go.get_position();
    _G.msg.post("#",Messages.Reset);
  end,
  'final', function(self,_) 
    _G.msg.post(".",defold.GoMessages.release_input_focus);
  end,
  'update', function(self,data,dt) 
    local gravity = _G.vmath.vector3(0,self.gravity,0);
    if (not data.ground_contact) then 
      local a = data.velocity;
      data.velocity = (a) + (gravity);
    end;
    local a1 = _G.go.get_position();
    local a2 = data.velocity;
    local b = (a2) * (dt);
    _G.go.set_position((a1) + (b));
    self:update_animation(data);
    data.correction = _G.vmath.vector3();
    data.ground_contact = false;
  end,
  'play_animation', function(self,data,anim) 
    if (data.anim ~= anim) then 
      _G.spine.play("#spinemodel",anim,_G.go.PLAYBACK_LOOP_FORWARD,0.15);
      data.anim = anim;
    end;
  end,
  'update_animation', function(self,data) 
    if (data.ground_contact) then 
      self:play_animation(data,_G.hash("run_right"));
    else
      if (data.velocity.y > 0) then 
        self:play_animation(data,_G.hash("jump_right"));
      else
        self:play_animation(data,_G.hash("fall_right"));
      end;
    end;
  end,
  'handle_geometry_contact', function(self,data,normal,distance) 
    local proj = _G.vmath.dot(data.correction,normal);
    local comp = (normal) * (distance - proj);
    local a = data.correction;
    data.correction = (a) + (comp);
    local a1 = _G.go.get_position();
    _G.go.set_position((a1) + (comp));
    if (normal.y > 0.7) then 
      data.ground_contact = true;
    end;
    proj = _G.vmath.dot(data.velocity,normal);
    if (proj < 0) then 
      local a2 = data.velocity;
      local b = (normal) * (proj);
      data.velocity = (a2) - (b);
    end;
  end,
  'on_message', function(self,data,message_id,message,sender) 
    if (message_id) == Messages.Reset then 
      data.velocity = _G.vmath.vector3(0,0,0);
      data.correction = _G.vmath.vector3();
      data.ground_contact = false;
      data.anim = nil;
      _G.go.set(".","euler.z",0);
      _G.go.set_position(data.position);
      _G.msg.post("#collisionobject",defold.GoMessages.enable);
    elseif (message_id) == defold.PhysicsMessages.contact_point_response then 
      if (message.group == _G.hash("danger")) then 
        self:play_animation(data,_G.hash("die_right"));
        _G.msg.post("#collisionobject",defold.GoMessages.disable);
        _G.go.animate(".","euler.z",_G.go.PLAYBACK_ONCE_FORWARD,160,_G.go.EASING_LINEAR,0.7);
        _G.go.animate(".","position.y",_G.go.PLAYBACK_ONCE_FORWARD,_G.go.get_position().y - 200,_G.go.EASING_INSINE,0.5,0.2,function(_,_1,_2) 
          _G.msg.post("controller#script",Messages.Reset);
        end);
      else
        if (message.group == _G.hash("geometry")) then 
          self:handle_geometry_contact(data,message.normal,message.distance);
        end;
      end; end;
  end,
  'on_input', function(self,data,action_id,action) 
    if ((action_id == _G.hash("jump")) or (action_id == _G.hash("touch"))) then 
      if (action.pressed) then 
        self:jump(data);
      else
        if (action.released) then 
          self:abort_jump(data);
        end;
      end;
    end;
    do return false end
  end,
  'jump', function(self,data) 
    if (data.ground_contact) then 
      data.velocity.y = self.jump_takeoff_speed;
    end;
  end,
  'abort_jump', function(self,data) 
    if (data.velocity.y > 0) then 
      data.velocity.y = data.velocity.y * 0.5;
    end;
  end
)
Hero.__super__ = defold.support.Script
setmetatable(Hero.prototype,{__index=defold.support.Script.prototype})

Messages.new = {}

Platform.new = function() 
  local self = _hx_new(Platform.prototype)
  Platform.super(self)
  return self
end
Platform.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Platform"] = Platform
Platform.prototype = _hx_a(
  'init', function(self,data) 
    data.speed = 9;
    data.coins = ({});
  end,
  'final', function(self,data) 
    lua.PairTools.ipairsEach(data.coins,function(i,p) 
      _G.go.delete(p);
    end);
  end,
  'update', function(self,data,dt) 
    local pos = _G.go.get_position();
    if (pos.x < -500) then 
      _G.msg.post("/level/controller#script",Messages.DeleteSpawn,_hx_o({__fields__={id=true},id=_G.go.get_id()}));
    end;
    pos.x = pos.x - data.speed;
    _G.go.set_position(pos);
  end,
  'on_message', function(self,data,message_id,message,sender) 
    if (message_id) == Platform.CreateCoinsMessage then 
      self:create_coins(data,message.coins);
    elseif (message_id) == Messages.SetSpeed then 
      data.speed = message.speed; end;
  end,
  'create_coins', function(self,data,coins) 
    local pos = _G.go.get_position();
    local x = (pos.x - (coins * 28.)) - 24;
    local _g1 = 1;
    while (_g1 < coins) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local coin = _G.factory.create("#coin_factory",_G.vmath.vector3(x + (i * 56),pos.y + 64,1));
      _G.msg.post(coin,defold.GoMessages.set_parent,_hx_o({__fields__={parent_id=true},parent_id=_G.go.get_id()}));
      _G.msg.post(coin,Messages.StartAnimation,_hx_o({__fields__={delay=true},delay=i / 10}));
      _G.table.insert(data.coins,coin);
      end;
  end
)
Platform.__super__ = defold.support.Script
setmetatable(Platform.prototype,{__index=defold.support.Script.prototype})

String.new = {}
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toString', function(self) 
    do return self end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

defold.GoMessages.new = {}

defold.PhysicsMessages.new = {}

defold.SpineMessages.new = {}

defold.types._Message.Message_Impl_.new = {}
defold.types._Message.Message_Impl_._new = function(s) 
  do return _G.hash(s) end;
end

haxe.io.Eof.new = {}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function() 
    do return cur_val ~= nil end;
  end}) end;
end

lua.PairTools.new = {}
lua.PairTools.ipairsEach = function(table,func) 
  for i,v in _G.ipairs(table) do func(i,v) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

Controller.grid = 460
Controller.platform_heights = _hx_tab_array({[0]=100, 200, 350 }, 3)
Controller.coins = 3
Ground.pieces = _hx_tab_array({[0]="ground0", "ground1", "ground2", "ground3", "ground4", "ground5", "ground6" }, 7)
Messages.StartAnimation = _G.hash("start_animation")
Messages.Reset = _G.hash("reset")
Messages.DeleteSpawn = _G.hash("delete_spawn")
Messages.SetSpeed = _G.hash("set_speed")
Platform.CreateCoinsMessage = _G.hash("create_coins")
defold.GoMessages.acquire_input_focus = _G.hash("acquire_input_focus")
defold.GoMessages.disable = _G.hash("disable")
defold.GoMessages.enable = _G.hash("enable")
defold.GoMessages.release_input_focus = _G.hash("release_input_focus")
defold.GoMessages.request_transform = _G.hash("request_transform")
defold.GoMessages.set_parent = _G.hash("set_parent")
defold.GoMessages.transform_response = _G.hash("transform_response")
defold.PhysicsMessages.apply_force = _G.hash("apply_force")
defold.PhysicsMessages.collision_response = _G.hash("collision_response")
defold.PhysicsMessages.contact_point_response = _G.hash("contact_point_response")
defold.PhysicsMessages.ray_cast_response = _G.hash("ray_cast_response")
defold.PhysicsMessages.request_velocity = _G.hash("request_velocity")
defold.PhysicsMessages.trigger_response = _G.hash("trigger_response")
defold.PhysicsMessages.velocity_response = _G.hash("velocity_response")
defold.SpineMessages.SpineAnimationDone = _G.hash("spine_animation_done")
defold.SpineMessages.SpineEvent = _G.hash("spine_event")
lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
do

end
_G.math.randomseed(_G.os.time());
return _hx_exports
